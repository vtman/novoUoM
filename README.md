# novoUoM

<h1>Codes for the NOVO project (proton therapy)</h1>

<nav>
  <ul>
    <li><a href="#link_coin">Finding coincident events</a></li>
    <li><a href="#link_coin_extract">extractTimeStamps: extract time stamps from ROOT files</a></li>
    <li><a href="#link_coin_extract3t">extractTimeStamps3t</a></li>
    <li><a href="#link_coin_radix">treeRadixSort: sort the binary data accoring to the time stamps</a></li>	  
    <li><a href="#link_coin_merge">mergeSort: merging data from all trees</a></li>
    <li><a href="#link_timeDiff">timeDifference3t: time diffrences between events</a></li>
    <li><a href="#link_coin_coin">coinBinarySingle: searching for coincident events</a></li>
    <li><a href="#link_coin_bin2root">coinRoot: forming an output ROOT file</a></li>
    <li><a href="#link_coin_bin2txt">timeStampBin2Txt: display time stamp information</a></li>
    <li><a href="#link_coin_root2txt">root2txt: save data from ROOT files</a></li>
    <li><a href="#link_coin_compilation">Compilation</a></li>
  </ul>
  </nav>

<h2 id="link_coin">Finding coincident events</h2>

The experimental setup contains a set of scintillation bars. Detector elements are positioned at the ends of these bars and record the signal's waveforms generated by scintillations within the bars. Digitiser boards are connected to detector elements and can acquire data. There are several channels for each board (for the current boards we may have up to 16 channels). By default, signals from the opposite ends of scintillation bars are in pairs (neighbouring odd/even indices of the channels). The index of the channels start from 0. Channels 14 and 15 are not in use.

The system records data as ROOT files (see <a href="https://root.cern/">CERN website</a>). Each ROOT file contains a set of trees corresponding to digitiser boards. There may be other trees in the file; however, we store all data in trees named <b>dta</b>, <b>dtb</b>, etc. Each tree contains columns of data called branches. All branches within one tree have the same number of elements (entries).

Note that a digitiser board writes data in chunks. We cannot guarantee that the events are in order within a chunk. However, consequent chunks are in order, i.e. an event within a chunk <tt>I</tt> is always before any event from chunk <tt>I+1</tt>. The size of the chunk varies, but it is possible to estimate its maximum size.

The goal is to identify those scintillation events that may be responsible for multiple scintillation events within different scintillation bars. Therefore, we first need to find scintillation events occurring within a short time frame within one bar, i.e. timestamps corresponding to a pair of odd/even channels (of the same bar) are close to each other (short-time). Then, among all possible pairs of such events, we find pairs of events that are within a large time frame (long-time). We ignore all other scintillation events.

The goal is to have an input ROOT file, perform various processing and get an output ROOT file containing all the data as the original input file but only for coincident events.



<h3 id="link_coin_extract">extractTimeStamps: extract time stamps from ROOT files</h3>

We consider all trees in an input ROOT file that have three-symbol names and start with <b>dt</b>. We ignore all other trees. For each tree, we create a binary output file containing information about the time stamps. We assume that there are at least three branches in each tree and there are branches named <tt>channel</tt> (1 byte), <tt>timestamp</tt> (4 bytes) and <tt>timestampExtended</tt> (2 bytes). For each scintilaltion event we form a 18-byte block of data: 4 bytes of <tt>timestamp</tt>, 2 bytes of <tt>timestampExtended</tt>, 2 bytes of zeros, 8 bytes of the entry's index, 1 byte of <tt>channel</tt>, 1 byte of the digitiser board's index). While we have only <tt>32 + 16</tt> bits for the time stamp, we pad the number to form the <tt>64</tt>-bit number.

<h4>Parameters</h4>

<ol>
  <li>Input ROOT file (string)</li>
  <li>Output folder (string)</li>
  <li>Prefix (string)</li>
</ol>

<tt>extractTimeStamps.exe D:\NOVO\conData\in\det_000206.root D:\NOVO\conData\out test</tt>


<h3 id="link_coin_extract3t">extractTimeStamps3t</h3>

ROOT files contain a <tt>time</tt> branch, which contains fine times and real numbers. In fact, these numbers are fractions <tt>k/1024</tt>. Therefore we convert a given fine time number <tt>f</tt> into a 10-bit number <tt>k</tt> and form one 64-bit number which are the concatenation of 10-bit <tt>k</tt> (an equvalent of the fine time), 32-bit <tt>timestamp</tt> and 16-bit <tt>timestampExtended</tt>. Thus, the resulting 3T-value (three times) is a 58-bit number padded with zeros. There is room for changes if future boards/software provide us with other approximations, e.g., 12-bit, of fine times. In case of large ROOT files values for <tt>timestampExtended</tt> mat reach the maximum value of <tt>65535</tt> and then start from <tt>0</tt> again. The new version of the code accounts for such cases, so the final timestamp may have more than 58 bits. In addition, the last byte of an 18-bit block has the board index, i.e., 0 for <b>dta</b>, 1 for <b>dtb</b>, etc. The same input/output parameters as for the original code.


<h3 id="link_coin_radix">treeRadixSort: sort the binary data accoring to the time stamps</h3>

We consider the binary files formed in the previous step. Time stamps are the first 64 bits for each 16-byte block of data. We use the simplest version of the radix sort algorithm. Starting from the least-significant bit, we form two blocks of data corresponding to <tt>0</tt> and <tt>1</tt> values for the chosen bit, then concatenate these two blocks and consider the next bit. To speed up the processing, we find the smallest time stamp and subtract it from all entries we are given, then perform the radix sort and add up the original time stamp. In this way, we have to consider fewer bits.

The code uses multiple threads. We split the original records into large chunks of rows, sorted them, and saved the results to the final file. Since the size of blocks used by the digitiser board to write data to ROOT files is unknown, it is possible that the time stamps for large blocks in the current code are not for neighbouring blocks. Therefore, we need to perform another radix sorting near the interfaces of these blocks. 

<h4>Parameters</h4>

<ol>
  <li>Input ROOT file (string)</li>
  <li>Output folder (string)</li>
  <li>Prefix (string)</li>
</ol>

<tt>treeRadixSort.exe D:\NOVO\conData\in\det_000206.root D:\NOVO\conData\out test</tt>

The 3T-version has the same functionality.

<h3 id="link_coin_merge">mergeSort: merging data from all trees</h3>

We have several binary files sorted by time stamp values. We should merge them into one file and keep the time stamps sorted. For this purpose, we find the maximum value of the time stamp for all files. Then we want to split all data into smaller chunks to be processed by one thread independently. So, if there are <tt>N</tt> files, then all <tt>N</tt> chunks considered by a one thread should have the same range of values for time stamps. Therefore, we first process each file and find the start positions of these blocks. Then each thread can safely process the data as there is no chance that there are any other rows of data for the chosen range of time stamps outside these <tt>N</tt> blocks. Each thread uses the standard merge sort algorithm.

<h4>Parameters</h4>

<ol>
  <li>Input ROOT file (string)</li>
  <li>Output folder (string)</li>
  <li>Prefix (string)</li>
</ol>

<tt>mergeSort.exe D:\NOVO\conData\in\det_000206.root D:\NOVO\conData\out test</tt>

The 3T-version has the same functionality.


<h3 id="link_timeDiff">timeDifference3t: time diffrences between events</h3>

We use the sorted binary files and for each channel (to be more precise, the <tt>CB</tt> value, which is <tt>16*Board + Channel</tt>), we find the time of the latest event. So, for each new event, we calculate the distance to events related to all other <tt>CB</tt> values. If the distance falls within a range, we increment the corresponding counter. In some sense, this process allows us to compute statistics for pairs of coincident events (whether or not they are related to real events; this does not matter). Events for channels <tt>14</tt> and <tt>15</tt> are ignored here.

<h4>Parameters</h4>

<ol>
  <li>Input/output folder (string)</li>
  <li>File prefix (string)</li>
  <li>Number of bits, short (integer, non-negative)</li>
  <li>Number of bits, long (integer, non-negative)</li>
  <li>Number of samples (integer, positive)</li>
</ol>

<tt>timeDifference3t.exe D:\NOVO\2025_02_Cf252\test\temp 211 2 4 200</tt>

The code does not use the original ROOT file but only the binary file created by the <tt>mergeSort3t</tt> code. So, if an IO folder is <tt>D:\NOVO\2025_02_Cf252\test\temp</tt> and the prefix is <tt>211</tt>, then we aim to process <tt>D:\NOVO\2025_02_Cf252\test\temp\211_merged.bin</tt> file. In the IO folder, we aim to produce <tt>211_timeDifferenceShort.txt</tt> and <tt>211_timeDifferenceLong.txt</tt>. The "short" file contains distributions for channels belonging to the same rod, i.e. 0 and 1, 18 and 19. The "long" file contains information about different rods. In the code, you comment out blocks that write distributions to single files in the <tt>data</tt> folder (we assume this folder exists, i.e., <tt>D:\NOVO\2025_02_Cf252\test\temp\data</tt>). Time stamps are integer numbers, so while it is possible to store distributions for all integer values within a range, we combine neighbouring values (bins for output values). The corresponding number of bits determines the number of integer values per bin. For example, if the number of bits is <tt>3</tt>, then the bin contains <tt>2^3 = 8</tt> integers. The first column of output files contains the "central" integer value. So, value <tt>0</tt> for the above example corresponds to values found for <tt>-4</tt>, <tt>-3</tt>, <tt>-2</tt>, <tt>-1</tt>, <tt>0</tt>, <tt>1</tt>, <tt>2</tt>, <tt>3</tt>. As a result, you may see that time differences for swapped pairs of channels, i.e. <tt>3-10</tt> and <tt>10-3</tt>, may differ slightly (if we mirror them). For example the values for <tt>-4</tt> will go to bin <tt>0</tt>, while for the swapped channels we get <tt>4</tt>, which corresponds to <tt>8</tt> bin (from <tt>4</tt> to <tt>11</tt>).

If <tt>N</tt> is the number of samples, then we have <tt>2 N + 1</tt> bins for output files. The number of bins is the same for "short" and "long" versions. However, the bin sizes differ.

The code assumes that there are two digitiser boards only. You may change this number (<tt>const int MAX_BOARDS = 2;</tt>). Note that output files report only non-zero distributions. If there are no events for a pair of channels (within a given range), the no output files (or columns) are generated.


<h3 id="link_coin_coin">coinBinarySingle: searching for coincident events</h3>

Processing the merged binary file to get another binary file for coincident events. Controlled by two time parameters. The first parameter determines that an event is recorded on the same bar by two channels. The second parameter specifies the time frame for events taking place in different bars. Single-threaded code. The output is also a binary file.

<h4>Parameters</h4>

<ol>
  <li>Input binary file (string)</li>
  <li>Output binary file (string)</li>
  <li>timeStamp for the same bar (integer, positive)</li>
  <li>timeStamp for the different bars (integer, positive)</li>
</ol>

<tt>coinBinarySingle.exe D:\NOVO\conData\out\test_merged.bin D:\NOVO\conData\out\test_cbs.bin 2 200</tt>




<h3 id="link_coin_bin2root">coinRoot: forming an output ROOT file</h3>

We use the given binary file (for coincident events) to extract data from the original ROOT file and form a new ROOT file.

<h4>Parameters</h4>

<ol>
  <li>Input ROOT file (string)</li>
  <li>Binary file-manager (string)</li>
  <li>Output ROOT file (string)</li>
</ol>

<tt>coinRoot.exe D:\NOVO\conData\in\det_000206.root D:\NOVO\conData\out\test_cbs.bin D:\NOVO\conData\out\ts_000206_out.root</tt>



<h3 id="link_coin_bin2txt">timeStampBin2Txt: display time stamp information</h3>

Read an input binary file and write down the information as a text file.

<h4>Parameters</h4>

<ol>
  <li>Input binary file (string)</li>
  <li>Output text file (string)</li>
  <li>The first entry (start with 0, int)</li>
  <li>The number of entries (if < 0, then all remaining, int)</li>
</ol>

<tt>timeStampBin2Txt.exe D:\NOVO\conData\out\test_merged.bin D:\NOVO\conData\out\test_merged.txt 123456 1000</tt>



<h3 id="link_coin_root2txt">root2txt: save data from ROOT files</h3>

Extract data from a ROOT file and save it as a text file. A list of trees is specified (or <b>all</b>). A list of branches is given (or <b>all</b>). Only branches with single variables are processed (no arrays). The first entry and the total number of entries to be saved are the input parameters.

<h4>Parameters</h4>

<ol>
  <li>Input ROOT file (string)</li>
  <li>Output folder (string)</li>
  <li>Output prefix (string)</li>
  <li>List of trees to be processed (comma-separated or all for all trees; string)</li>
  <li>List of branches to be processed (comma-separated or all for all trees; string)</li>
  <li>Index of the first entry (0 for the first; integer)</li>
  <li>Number of entries to be processed ( if < 0, then all; integer)</li>
</ol>

<tt>root2txt.exe D:\NOVO\conData\out\ts_000206_out.root D:\NOVO\conData\out cc all timestamp,timestampExtended,channel,board 1234 1000</tt>




<h3 id="link_coin_compilation">Compilation</h3>

The ROOT software should be installed. 

If Intel's compiler is available (free <a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/toolkits.html">oneAPI toolkets<a>), then you may compile similar to

<tt>icpx treeRadixSort.cpp -o treeRadixSort.exe $(root-config --cflags --libs) -Wall -O2 -qopenmp</tt>

In case of g++/gcc

<tt>g++ treeRadixSort.cpp -o treeRadixSort.exe $(root-config --cflags --libs) -Wall -O2 -fopenmp</tt>

In case of Windows and Visual Studio you need to include corresponding ROOT directories in "VC++ Directories" ("Include Directories", "Library Directories", "Executable Directories"); sometimes it is better to specify a working directory in "Debugging -> Working Directory" (the  bin directory of the ROOT folder); add "_CRT_SECURE_NO_WARNINGS" to "C/C++ -> Preprocessor -> Preprocessor Definitions"; in "C/C++ -> Language" choose C++17 for C and C++; "Optimization -> Optmization" to Maximum Optmization (Favor Speed) (/O2); set to use parallel version of openMP (its in "C/C++ -> Language -> open MP support"; add /Zc:__cplusplus in "C/C++ -> Command Line -> Additional Options"; add "libCore.lib;libTree.lib;libRIO.lib" in "Linker -> Input -> Additional Dependences".






